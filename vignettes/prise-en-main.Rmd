---
title: "Introduction à gescodgeo"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction à gescodgeo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(digits = 4)
```

Le code géographique des communes (COG) est modifié chaque année, avec des fusions 
et des défusions de commune. Pour apparier des sources statistiques qui n'ont 
pas le même COG, ou encore pour présenter des résultats statistiques dans un 
découpage communal plus récent, il faut tenir compte de ces changements. Cette 
page présente un exemple de gestion des codes géographiques des communes avec 
gescodgeo.

Je pars d'une data frame sur les trajets domicile-travail dans quelques communes.

```{r echo = FALSE}
# Un exemple de Data frame avec quelques communes :
data <- dplyr::tibble(
  # Code des communes
  COM19 = c("14001", "14712", "21183", "21507", "45287", "45307"),
  
  # Nombre d'actifs qui se déplacent
  IPONDI = c(12062.88130, 2266.15705, 384.93408, 125, 101, 418.26613),
  
  # Distance moyenne
  DIST = c(18.02278, 23.66685, 20.69776, 20.89907, 40.36829, 31.30092),

  # Durée moyenne des trajets domicile-travail
  DUREE = c(18.11675, 21.15484, 22.43131, 23.24867, 40.30286, 29.91029)

)
```
```{r message = FALSE}
# Librairies utilisées dans cet exemple
library(dplyr)
library(gescodgeo)

# Déplacements domicile-travail dans quelques communes
data
```

Le nombre de navetteurs (variable IPONDI) provient du millésime 2017 de l'exploitation complémentaire
du recensement de la population, dont le code des communes est en géographie 2019 (variable COM19). 
Les distances (DIST) et durées moyennes (DUREE) proviennent de Metric-OSRM et de l'investissement AT27.
Je souhaite convertir cette base en géographie 2020, par exemple pour l'apparier 
avec un nouveau millésime du recensement.

## Vérifier le COG des communes

La fonction `check_cog()` permet de détecter des codes communes qui ne sont pas 
conformes au code officiel géographique d'une année donnée.

```{r}
data %>% check_cog(cog = 2019)
data %>% check_cog(cog = 2020)
```

Tous les codes des communes sont bien dans le code officiel géographique 2019. 
En revanche, les communes 21507 et 45287 ne sont pas dans le code officiel géographique 2020.

En cas de doute sur un code géographique particulier, la fonction `cog_events()`
renvoie l'historique des évenements du COG concernant la commune 
depuis 2008.

```{r}
cog_events("21507")
```

Cela permet notamment d'identifier des fusions de communes quand la colonne 
NB_COM_INI est supérieure à 1 ou des scissions de communes quand la colonne 
NB_COM_FIN est supérieure à  1.

## Voir la table de passage entre deux années

La fonction `cog_transition()` renvoie la table de passage des communes entre 
deux années du code officiel géographique.

```{r}
cog_transition(2019, 2020)
```

Entre 2019 et 2020, la commune 14712 s'est scindée pour former les communes 14666 et 14712. 
Les communes 45287 et 45307 ont fusionné pour former la commune 45307. 
Cela explique pourquoi le code 45287 n'est pas conforme au code officiel géographique 2020.

## Changer le COG des communes

Avec la fonction `change_cog()`, j'ajoute une colonne COM20 contenant les codes des communes convertis dans le 
code officiel géographique 2020.

```{r}
# Change la géographie de 2019 à 2020 avec une nouvelle variable COM20
new <- data %>% 
  change_cog(cog_from = 2019, cog_to = 2020, from = COM19, to = "COM20")
```

Pour tenir compte de la scission de la commune 14712, la ligne est dupliquée 
avec les nouveaux codes 14712 et 14666. Pour tenir compte de la fusion des 
communes 21183 et 45307, les deux lignes présentent le nouveau code 45307.

## Répartir les effectifs dans les communes scindées

La nouvelle base ne respecte pas le nombre total de navetteurs, car la ligne de la 
commune 14712 est dupliquée. Une manière simple de rétablir les effectifs 
consiste à appliquer un ratio selon le nombre de commune fille.

```{r}
# Répartit le nombre de navetteur (IPONDI) dans les communes scindées
new <- new %>%
  group_by(COM19) %>%
  mutate(IPONDI = IPONDI / n()) %>%
  ungroup()
new
```

Pour aller plus loin, on peut utiliser une clé de répartition issue de la table 
de passage pour tenir compte des poids respectifs des communes filles : 
voir  `vignette("base-individuelle")`.

## Revenir à une seule ligne par commune

Pour revenir à une base individuelle, je dois agrégeger les effectifs et 
recalculer les moyennes dans les communes qui ont fusionnées.

```{r}
# Agrège selon le code géographique 2020 et recalcule les variables numériques
new <- new %>%
  group_by(COM20) %>%
  summarise(DIST = weighted.mean(DIST, IPONDI),
            DUREE = weighted.mean(DUREE, IPONDI),
            IPONDI = sum(IPONDI),
            .groups = "drop")
new
```

On peut vérifier que les agrégats sont bien respectés :
```{r}
# Avant le changement de géographie
data %>% summarise(DIST = weighted.mean(DIST, IPONDI),
                   DUREE = weighted.mean(DUREE, IPONDI),
                   IPONDI = sum(IPONDI))
# Après le changement de géographie
new %>% summarise(DIST = weighted.mean(DIST, IPONDI),
                  DUREE = weighted.mean(DUREE, IPONDI),
                  IPONDI = sum(IPONDI))
```
Pour des bases agrégées ou semi-agrégées par commune, on peut aussi utiliser 
la fonction `adapt_to_change()` : voir `vignette("base-communale")`. 
Cette fonction permet en outre d'attribuer une catégorie majoritaire en cas 
fusion de commune, utile par exemple pour transposer un zonage dans une autre 
géographie.

Si on n'a pas besoin de disposer de l'exhaustivité des communes dans la base 
finale, on peut aussi utiliser l'option `one_to_one` dans la fonction 
`change_cog()`, qui permet de ne pas dupliquer les communes scindées, 
voir la  deuxième méthode de la `vignette("base-individuelle")`. 
 
## Gérer les arrondissements municipaux

Selon les sources statistiques, les communes de Paris, Lyon et Marseille peuvent 
être (ou ne pas être) découpées en arrondissements municipaux. Les fonctions
`com_to_arm()` et `arm_to_com()` permettent de gérer ces situations.

```{r}
# Passer de l'arrondissement municipal à la commune (le cas échéant)
data.frame(ARM = c("75101", "75102", "13201", "13202", "13001")) %>% 
  # Conversion des arrondissments municipaux en communes
  arm_to_com(from = ARM, to = "COM")
```
## Compléter les départements et les régions

D'autres fonctions de gescodgeo permettent de compléter les informations 
géographiques au niveau départemental ou régional.

```{r}
data.frame(COM = c("75101", "75102", "13201", "13202", "13001")) %>% 
  # Ajout des départements
  com_to_dep(from = COM, to = "DEP") %>% 
  # Ajout des régions
  dep_to_reg(from = DEP, to = "REG") 
```

La plupart de ces méthodes contiennent leur réciproque (par exemple `reg_to_dep()`)
et peuvent s'appliquer indifférement à une data frame ou à un vecteur.

```{r}
# Arrondissements de Lyon
com_to_arm("69123")
# Départements de Corse et de PACA
reg_to_dep(c("93","94")) 
# Pour une data frame, les méthodes com_to_arm() et reg_to_dep() ajoutent des lignes
data.frame(REG = "94") %>% reg_to_dep()
```

